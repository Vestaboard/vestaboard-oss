From 217b6dc298156bdb0d6aea9ea93e7e394a5ff091 Mon Sep 17 00:00:00 2001
From: Florian Weimer <fweimer@redhat.com>
Date: Tue, 1 Jun 2021 17:51:41 +0200
Subject: [PATCH] Fix use of __pthread_attr_copy in mq_notify (bug 27896)

__pthread_attr_copy can fail and does not initialize the attribute
structure in that case.

If __pthread_attr_copy is never called and there is no allocated
attribute, pthread_attr_destroy should not be called, otherwise
there is a null pointer dereference in rt/tst-mqueue6.

Fixes commit 42d359350510506b87101cf77202fefcbfc790cb
("Use __pthread_attr_copy in mq_notify (bug 27896)").

Reviewed-by: Siddhesh Poyarekar <siddhesh@sourceware.org>

https://sourceware.org/bugzilla/attachment.cgi?id=13497

Upstream-Status: Backport
CVE: CVE-2021-33574 patch#2
Signed-off-by: Armin Kuster &lt;akuster@mvista.com&gt;

---
Index: git/sysdeps/unix/sysv/linux/mq_notify.c
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/mq_notify.c
+++ git/sysdeps/unix/sysv/linux/mq_notify.c
@@ -260,7 +260,34 @@ mq_notify (mqd_t mqdes, const struct sig
       if (data.attr == NULL)
 	return -1;
 
-      __pthread_attr_copy (data.attr, notification->sigev_notify_attributes);
+      memcpy (data.attr, notification->sigev_notify_attributes,
+        sizeof (pthread_attr_t));
+
+      struct pthread_attr *source =
+     (struct pthread_attr *) (notification->sigev_notify_attributes);
+      struct pthread_attr *target = (struct pthread_attr *) (data.attr);
+      cpu_set_t *newp;
+      cpu_set_t *cpuset = source->cpuset;
+      size_t cpusetsize = source->cpusetsize;
+
+      /* alloc a new memory for cpuset to avoid use after free */
+      if (cpuset != NULL && cpusetsize > 0)
+   {
+     newp = (cpu_set_t *) malloc (cpusetsize);
+     if (newp == NULL)
+       {
+         free(data.attr);
+         return -1;
+       }
+
+     memcpy (newp, cpuset, cpusetsize);
+     target->cpuset = newp;
+   }
+      else
+   {
+     target->cpuset = NULL;
+     target->cpusetsize = 0;
+   }
     }
 
   /* Construct the new request.  */
@@ -273,7 +300,7 @@ mq_notify (mqd_t mqdes, const struct sig
   int retval = INLINE_SYSCALL (mq_notify, 2, mqdes, &se);
 
   /* If it failed, free the allocated memory.  */
-  if (__glibc_unlikely (retval != 0))
+   if (retval != 0 && data.attr != NULL)
     {
       pthread_attr_destroy (data.attr);
       free (data.attr);
